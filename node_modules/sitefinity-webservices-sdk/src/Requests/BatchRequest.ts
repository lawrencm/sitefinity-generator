import { RequestFactory } from "./RequestFactory";
import { RequestBase } from './Request';
import { BlobBuilder } from '../BlobBuilder';
import { utils } from '../utils';

var headerNames = require("../Headers").headerNames;
var httpMethods = require("../HttpMethods").default;

/**
 * @classdesc The transaction class is used to group operations that involve data manipulation together and execute them as a single atomic operation.
 * @class Transaction
 * @param {object} urlOptions - The url options that are passed to the {@link _factory} object.
 * @param {object} _factory - The factory object used for request generation.
 */
class Transaction {
    private urlOptions: any;
    private _factory: RequestFactory;
    private _requests: any[];
    public id: number;
    public _counter: number;

    constructor(urlOptions, _factory) {
        this.urlOptions = urlOptions;
        this._factory = _factory;
        this._requests = [];
        this._counter = 0;
    }

    upload(parameters: any) {
        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            data: parameters.data,
            contentType: parameters.contentType,
            fileName: parameters.fileName,
            key: parameters.key,
            uploadProperties: JSON.stringify(parameters.uploadProperties)
        };

        var request = this._factory.upload(options);

        return this.addRequest(this, request);
    }

    /**
    * Adds a POST request to create a single item.
    * @memberOf Transaction
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {object} parameters.data - The payload of the request.
    */
    create(parameters: any) {
        if (!(parameters || parameters.entitySet))
            throw "entitySet is required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            key: parameters.key,
            action: parameters.action,
            urlOptions: urlOptions,
            data: JSON.stringify(parameters.data)
        };

        var request = this._factory.create(options);

        return this.addRequest(this, request);
    }

    /**
    * Adds a POST request to execute an operation on single item.
    * @memberOf Transaction
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {string} parameters.key - The identifier of the item to be updated.
    * @param {object} parameters.data - The payload of the request.
    */
    operation(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key || parameters.data))
            throw "parameters: entitySet, key and data are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            key: parameters.key,
            action: 'operation',
            data: JSON.stringify(parameters.data)
        };

        var request = this._factory.create(options);

        this._overrideUrlGeneration(request, parameters.key, 'operation', options.urlOptions);
        this.addRequest(this, request);
    }

    /**
    * Adds a PATCH request to update a single item.
    * @memberOf Transaction
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {bool} parameters.saveTemp - A flag indicating whether to save in temp.
    * @param {string} parameters.key - The identifier of the item to be updated.
    * @param {object} parameters.data - The payload of the request.
    */
    update(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key || parameters.data))
            throw "parameters: entitySet, key and data are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            saveTemp: parameters.saveTemp,
            key: parameters.key,
            data: JSON.stringify(parameters.data)
        };

        var request = this._factory.update(options);

        this._overrideUrlGeneration(request, parameters.key, undefined, options.urlOptions);
        this.addRequest(this, request);
    }

    /**
    * Adds a DELETE request to delete a single item.
    * @memberOf Transaction
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {string} parameters.key - The identifier of the item to be deleted.
    */
    destroy(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key))
            throw "parameters: entitySet and key are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            key: parameters.key
        };

        var request = this._factory.destroy(options);

        this._overrideUrlGeneration(request, parameters.key, undefined, options.urlOptions);

        this.addRequest(this, request);
    }

    /**
    * Adds a DELETE request to retrieve the delete all of the associated members in the relation property.
    * @memberOf Transaction
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {string} parameters.key - The identifier of the item.
    * @param {string} parameters.navigationProperty - The name of the navigation property.
    */
    destroyRelated(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key))
            throw "parameters: entitySet and key are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            key: parameters.key,
            navigationProperty: parameters.navigationProperty
        };

        var request = this._factory.destroyRelated(options);

        var navigationPropertyURL = (request as any).navigationProperty + '/$ref';
        this._overrideUrlGeneration(request, parameters.key, navigationPropertyURL, options.urlOptions);

        this.addRequest(this, request);
    }

    /**
    * Adds a DELETE request to retrieve the a single entry of the associated members in the relation property.
    * @memberOf Transaction
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {string} parameters.key - The identifier of the item.
    * @param {string} parameters.navigationProperty - The name of the navigation property.
    * @param {string} parameters.relatedKey - The identifier of the related item.
    */
    destroyRelatedById(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key || parameters.relatedKey || parameters.navigationProperty))
            throw "parameters: entitySet, key, relatedKey and navigationProperty are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            key: parameters.key,
            relatedKey: parameters.relatedKey,
            navigationProperty: parameters.navigationProperty
        };

        var request = this._factory.destroyRelatedById(options);

        this.addRequest(this, request);
    }

    /**
    * Adds a POST request to add a related item to the property collection.
    * @memberOf Transaction
    * @instance
    * @see {@link Data.createRelated}
    * @param {object} parameters - The parameters for the request.
    * @param {string} parameters.key - The identifier of the item.
    * @param {string} parameters.navigationProperty - The name of the navigation property
    */
    createRelated(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key || parameters.link || parameters.navigationProperty))
            throw "parameters: entitySet, key, link and navigationProperty are required!";

        // TODO: rethink about the urls
        var urlOptions = this.urlParametersClone(parameters.entitySet);

        for (var index = 0; index < this._requests.length; index += 1) {
            if (this._requests[index].id == parameters.link) {
                parameters.link = "$" + this._requests[index].id;
            }
        }

        var data = {
            '@odata.id': parameters.link
        }

        var options = {
            urlOptions: urlOptions,
            key: parameters.key,
            navigationProperty: parameters.navigationProperty,
            data: JSON.stringify(data)
        };

        var request = this._factory.createRelated(options);
        var navigationPropertyURL = (request as any).navigationProperty + '/$ref';
        this._overrideUrlGeneration(request, parameters.key, navigationPropertyURL, options.urlOptions);

        return this.addRequest(this, request);
    }

    _overrideUrlGeneration(request: any, key: string, additionalPropertyURL: string, sfParams: any) {
        // TODO: match requests with Content-ID's!
        // Content-ID's are the same as id's in _requests.
        for (var index = 0; index < this._requests.length; index += 1) {
            if (this._requests[index].id == key) {
                request._buildUrl = function () {
                    var uri = "$" + key;
                    if (additionalPropertyURL !== undefined) {
                        uri = uri + '/' + additionalPropertyURL;
                    }

                    if (sfParams) {
                        var queryString = request._getQueryString(sfParams);
                        if (queryString) {
                            uri = uri + queryString;
                        }
                    }

                    return uri;
                }
            }
        }
    }

    addRequest(that: any, request) {
        that._requests.push({ "id": that._counter, "request": request });
        return that._counter++;
    }

    urlParametersClone(entitySet: string) {
        var options = utils.clone(this.urlOptions);
        options.entitySet = entitySet;

        return options;
    }
}

/**
 * @classdesc The batch request class is used for grouping requests into a single batch request to execute on the server.
 * @class BatchRequest
 */
class BatchRequest extends RequestBase {
    private _factory: RequestFactory;
    private _requests: any[];
    private _counter: number;
    private boundary: any;
    private responseHeaderRegex: RegExp;
    private responseStatusRegex: RegExp;
    public static constants = {
        newLine: '\r\n'
    };

    constructor(options) {
        super(options);
        this._factory = options._factory;
        this._requests = [];
        this._counter = 0;
        this.boundary = this._createBoundary("sf_batch_");
        this.responseHeaderRegex = /^([^()<>@,;:\\"\/[\]?={} \t]+)\s?:\s?(.*)/;
        this.responseStatusRegex = /^HTTP\/1\.\d (\d{3}) (.*)$/i;
    }

    /**
    * Adds a GET request to retrieve a collection of items.
    * @memberOf BatchRequest
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {object} parameters.query - The {@link WhereQuery} with which to filter the items
    */
    get(parameters: any) {
        if (!(parameters || parameters.entitySet))
            throw "entitySet is required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);
        if (parameters && parameters.query)
            urlOptions.ODataParams = parameters.query;

        var options = {
            urlOptions: urlOptions,
            fallbackProperties: parameters.fallbackPropertyNames
        };

        var request = this._factory.get(options);

        this.addRequest(request);
    }

    /**
    * Adds a GET request for the retrieval of a single item.
    * @memberOf BatchRequest
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {object} parameters.query - The {@link QueryBase} object containing the OData query options that should be sent to the server.
    * @param {string} parameters.key - The identifier of the item to be retrieved.
    */
    getSingle(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key))
            throw "parameters: entitySet and key are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options: any = {
            urlOptions: urlOptions,
            key: parameters.key
        };

        if (parameters.query)
            options.ODataParams = parameters.query;

        var request = this._factory.getSingle(options);

        this.addRequest(request);
    }

    /**
    * Adds a GET request to get the property of a single item.
    * @memberOf BatchRequest
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {string} parameters.key - The identifier of the item.
    * @param {string} parameters.property - The name of the property to be retrieved.
    */
    getProperty(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key, parameters.property))
            throw "parameters: entitySet, key and property are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            key: parameters.key,
            navigationProperty: parameters.property
        };

        var request = this._factory.getProperty(options);

        this.addRequest(request);
    }

    /**
    * Adds a GET request to get the related property value of a single item.
    * @memberOf BatchRequest
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {string} parameters.key - The identifier of the item.
    * @param {string} parameters.navigationProperty - The name of the navigation property to be retrieved.
    */
    getRelated(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key || parameters.navigationProperty))
            throw "parameters: entitySet, key and navigationProperty are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            key: parameters.key,
            navigationProperty: parameters.navigationProperty
        };

        var request = this._factory.getRelated(options);

        this.addRequest(request);
    }

    /**
    * Adds a GET request to retrieve the related property value of a single item by the id of the related item.
    * @memberOf BatchRequest
    * @instance
    * @param {object} parameters - The parameters for the request.
    * @param {string} parameters.key - The identifier of the item.
    * @param {string} parameters.navigationProperty - The name of the navigation property to be retrieved.
    * @param {string} parameters.relatedKey - The identifier of the related item.
    */
    getRelatedById(parameters: any) {
        if (!(parameters || parameters.entitySet || parameters.key || parameters.relatedKey || parameters.navigationProperty))
            throw "parameters: entitySet, key, relatedKey and navigationProperty are required!";

        var urlOptions = this.urlParametersClone(parameters.entitySet);

        var options = {
            urlOptions: urlOptions,
            key: parameters.key,
            relatedKey: parameters.relatedKey,
            navigationProperty: parameters.navigationProperty
        };

        var request = this._factory.getRelatedById(options);

        this.addRequest(request);
    }

    /**
    * Begins a transaction.
    * @memberOf BatchRequest
    * @instance
    * @returns {@link Transaction}
    */
    beginTransaction() {
        var option = utils.clone(this.urlOptions);
        const newTransaction = new Transaction(option, this._factory);
        newTransaction.id = ++this._counter;
        return newTransaction;
    }

    /**
    * Ends a transaction.
    * @memberOf BatchRequest
    * @instance
    */
    endTransaction(transaction: any) {
        this._requests.push({
            id: transaction.id,
            request: transaction
        });
    }

    _getBody() {
        return this._buildRequestBody();
    }

    _getMethod() {
        return httpMethods.Post;
    }

    _getHeaders() {
        var contentType = "multipart/mixed; boundary=" + this.boundary;
        var headers = { };
        headers[headerNames.contentType] = contentType;

        return headers;
    }

    _buildUrl() {
        var url = this.urlOptions.baseUrl + "$batch";
        var queryString = this._getQueryString(this.urlOptions);

        if (queryString) {
            url += queryString
        }

        return url;
    }

    _parseResponse(http) {
        var context = {
            position: 0,
            boundaries: []
        };

        var pos = context.position;
        var partHeaders = this._readHeaders(http.getAllResponseHeaders(), context);
        var partContentType = this._contentType(partHeaders["content-type"]);
        if (partContentType && partContentType.mediaType == "multipart/mixed") {
            context.boundaries.push((partContentType.properties as any).boundary);
        }

        context.position = pos;

        var batchResponse = this._parseBatchResponse(http.responseText, context);
        var responseParsed = [];
        for (var i = 0; i < batchResponse.length; i++) {
            try {
                var finalResult = null;

                var singleResponse = batchResponse[i];
                var changesets = singleResponse.__changeResponses;
                if (changesets) {
                    finalResult = [];

                    for (var j = 0; j < changesets.length; j++) {
                        var changeset = changesets[j];
                        var response = changeset.response;
                        var responseResult = this._getResponseResult(response);
                        finalResult.push(responseResult);
                    }
                } else {
                    var response = singleResponse.response;
                    finalResult = this._getResponseResult(response);
                }

                var statusCodeCheck = function (r) {
                    return r.statusCode >= 400;
                };

                var isSuccessful = Array.isArray(finalResult) ?
                    finalResult.filter(statusCodeCheck).length === 0 :
                    !statusCodeCheck(finalResult);

                responseParsed.push({ isSuccessful: isSuccessful, response: finalResult });
            }
            catch (e) {
                // TODO: why continue ?
                continue;
            }
        }

        var isSuccessfulCheck = (r) => {
            return !r.isSuccessful;
        };

        var batchIsSuccessful = responseParsed.filter(isSuccessfulCheck).length === 0;
        return { data: responseParsed, isSuccessful: batchIsSuccessful };
    }

    _parseBatchResponse(text, context) {
        // get boundary from response
        var delimiter = "--" + this._currentBoundary(context);
        this._readTo(text, delimiter, context);
        this._readLine(text, context);

        var responses = [];
        var partEnd;
        while (partEnd !== "--" && context.position < text.length) {
            var partHeaders = this._readHeaders(text, context);
            var partContentType = this._contentType(partHeaders["content-type"]);
            var changeResponses;
            if (partContentType && partContentType.mediaType === "multipart/mixed") {
                context.boundaries.push((partContentType.properties as any).boundary);

                try {
                    changeResponses = this._parseBatchResponse(text, context);
                } catch (e) {
                    e.response = this._readResponse(text, context, delimiter);
                    changeResponses = [e];
                }
                responses.push({ __changeResponses: changeResponses });
                context.boundaries.pop();
                this._readTo(text, "--" + this._currentBoundary(context), context);
            } else {
                if (!partContentType || partContentType.mediaType !== "application/http") {
                    throw { message: "invalid MIME part type " };
                }
                // Skip empty line
                this._readLine(text, context);

                // Read the response
                var response: any = this._readResponse(text, context, delimiter);

                try {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        response = { message: response.statusCode + " Http request is OK", response: response };
                    } else {
                        // Keep track of failed responses and continue processing the batch.
                        response = { message: "HTTP request failed", response: response };
                    }
                } catch (e) {
                    response = e;
                }

                responses.push(response);
            }

            partEnd = text.substr(context.position, 2);

            // Ignore the incoming line.
            this._readLine(text, context);
        }

        return responses;
    }

    _getResponseResult(response) {
        var responseBody = response.body;
        var data = utils.parseStringToJson(responseBody);

        return {
            data: data,
            statusCode: response.statusCode,
            headers: response.headers
        };
    }

    _currentBoundary(context) {
        var boundaries = context.boundaries;
        return boundaries[boundaries.length - 1];
    }

    _contentType(str) {

        if (!str) {
            return null;
        }

        var contentTypeParts = str.split(";");
        var properties = {};

        var i, len;
        for (i = 1, len = contentTypeParts.length; i < len; i++) {
            var contentTypeParams = contentTypeParts[i].split("=");
            properties[contentTypeParams[0].replace(/^\s+|\s+$/g, '')] = contentTypeParams[1];
        }

        return { mediaType: contentTypeParts[0].replace(/^\s+|\s+$/g, ''), properties: properties };
    }

    _readTo(text, str, context) {
        var start = context.position || 0;
        var end = text.length;
        if (str) {
            end = text.indexOf(str, start);
            if (end === -1) {
                return null;
            }
            context.position = end + str.length;
        } else {
            context.position = end;
        }

        return text.substring(start, end);
    }

    _readLine(text, context) {
        return this._readTo(text, BatchRequest.constants.newLine, context);
    }

    _readHeaders(text, context) {
        var headers = {};
        var parts;
        var line;
        var pos;

        do {
            pos = context.position;
            line = this._readLine(text, context);
            parts = this.responseHeaderRegex.exec(line);
            if (parts !== null) {
                headers[parts[1].toLowerCase()] = parts[2];
            } else {
                // Whatever was found is not a header, so reset the context position.
                context.position = pos;
            }
        } while (line && parts);

        return headers;
    }

    _readResponse(text, context, delimiter) {
        // Read the status line.
        var pos = context.position;
        var match = this.responseStatusRegex.exec(this._readLine(text, context));

        var statusCode;
        var statusText;
        var headers;

        if (match) {
            statusCode = match[1];
            statusText = match[2];
            headers = this._readHeaders(text, context);
            this._readLine(text, context);
        } else {
            context.position = pos;
        }

        return {
            statusCode: statusCode,
            statusText: statusText,
            headers: headers,
            body: this._readTo(text, "\r\n" + delimiter, context)
        };
    }

    _buildRequestBody() {
        var builder = new BlobBuilder();
        builder.append('');

        for (var index = 0; index < this._requests.length; index += 1) {

            var request = this._requests[index].request;
            if (index != 0)
                builder.append(BatchRequest.constants.newLine + BatchRequest.constants.newLine);

            builder.append("--" + this.boundary);

            if (request instanceof Transaction) {
                builder.append(this._buildTransaction(request));
            }
            else {
                builder.append(this._buildRequest(request));
            }
        }

        builder.append(this._createDelimeter(this.boundary, true));
        return builder.build();
    }

    _buildRequest(request) {
        var builder = new BlobBuilder();
        builder.append(BatchRequest.constants.newLine + 'Content-Type: application/http' +
                    BatchRequest.constants.newLine + 'Content-Transfer-Encoding: binary' +
                    BatchRequest.constants.newLine +
                    BatchRequest.constants.newLine +
                    request._getMethod() +
                    ' ' + request._buildUrl() + ' HTTP/1.1');

        return builder.build();
    }

    _buildTransaction(transaction) {
        if (transaction._requests.length == 0)
            return;

        var builder = new BlobBuilder();
        builder.append(BatchRequest.constants.newLine);

        var changeset = this._createBoundary("sf_changeset_");
        builder.append('Content-Type: multipart/mixed; boundary=' + changeset);

        var changesetRequests = transaction._requests;
        for (var index = 0; index < changesetRequests.length; index += 1) {
            var currentRequest = changesetRequests[index].request;

            builder.append(this._createDelimeter(changeset, false) +
                        BatchRequest.constants.newLine + 'Content-Type: application/http' +
                        BatchRequest.constants.newLine + 'Content-Transfer-Encoding: binary' +
                        BatchRequest.constants.newLine + 'Content-ID: ' + changesetRequests[index].id);

            var requestUrl = currentRequest._buildUrl();
            builder.append('\r\n\r\n' + currentRequest._getMethod() + ' ' + requestUrl + ' HTTP/1.1');

            var headers = currentRequest._getHeaders();
            var headerNames = Object.keys(headers);
            for (var i = 0; i < headerNames.length; i++) {
                var headerName = headerNames[i];
                builder.append(BatchRequest.constants.newLine + headerName + ": " + headers[headerName]);
            }

            var body = currentRequest._getBody();
            if (body) {
                builder.append('\r\n\r\n');
                builder.append(body);
            }
        }

        builder.append(this._createDelimeter(changeset, true));

        return builder.build();
    }

    _createDelimeter(boundary, close) {
        var result = BatchRequest.constants.newLine +
            BatchRequest.constants.newLine
            + "--" + boundary;
        if (close)
            result += "--";
        return result;
    }

    _createBoundary(prefix) {
        return prefix + utils.hex16() + '-' + utils.hex16() + '-' + utils.hex16();
    }

    addRequest(request) {
        return Transaction.prototype.addRequest(this, request);
    }

    urlParametersClone(entitySet) {
        return Transaction.prototype.urlParametersClone.call(this, entitySet);
    }

}
module.exports = BatchRequest;
