import { RequestBase } from './Request';
import { utils } from '../utils';

var headerNames = require("../Headers").headerNames;
var XMLHttpRequestDone = 4;

function isFunction(func) {
    return typeof func === 'function';
}

export class ExecutableRequest {
    private request: RequestBase;
    private handlers: any;
    private token: any;
    private enableUnlimitedChoices: boolean;

    constructor(options: any) {
        this.request = options.request;
        this.handlers = options.handlers;
        this.token = options.token;
        this.enableUnlimitedChoices = options.enableUnlimitedChoices;
    }

    execute() {
        this._execute();
    }

    _execute() {
        var http = new XMLHttpRequest();

        http.onreadystatechange = () => {
            if (http.readyState === XMLHttpRequestDone) {
                if (http.status > 0) {
                    var data = this.request._parseResponse(http);

                    if (http.status >= 200 && http.status <= 206) {

                        if (isFunction(this.request.successCb)) {
                            this.request.successCb(data);
                        }

                        if (this.handlers && isFunction(this.handlers.successCb)) {
                            this.handlers.successCb(data);
                        }
                    }
                    else if (http.status >= 400) {
                        // When the data is string, we save the string as message
                        // and convert the data to normal object with message property
                        if (utils.isString(data)) {
                            var message = data;
                            data = {
                                message: message
                            };
                        }

                        data.status = http.status;

                        // in case of errors we would like there to be one handler for all of the errors
                        if (isFunction(this.request.failureCb)) {
                            this.request.failureCb(data);
                        }

                        if (this.handlers && isFunction(this.handlers.failureCb)) {
                            this.handlers.failureCb(data);
                        }
                    }
                }
            }
        };

        if (isFunction(this.request.progressCb)) {
            if (http.upload) {
                var that = this;
                http.upload.onprogress = function (event) {
                    that.request.progressCb(event);
                };
            }
        }

        var method = this._getMethod();
        var url = this._buildUrl();
        http.open(method, url, true);
        this.setHeaders(http, this._getHeaders());

        http.send(this._getBody());
    }

    setHeaders(http: any, headers: any) {
        var headerKeys = Object.keys(headers);
        for (var i = 0; i < headerKeys.length; i++) {
            var currentHeaderName = headerKeys[i];
            http.setRequestHeader(currentHeaderName, headers[currentHeaderName]);
        }

        if (this.token) {
            if (typeof this.token === 'string') {
                // for backward compatibility
                http.setRequestHeader(headerNames.authorization, this.token);
            } else {
                http.setRequestHeader(headerNames.authorization, this.token.type + " " + this.token.value);
            }
        }

        if (this.enableUnlimitedChoices) {
            http.setRequestHeader(headerNames.choicesBinaryRepresentation, true);
        }

        // for backward compatibility
        http.setRequestHeader(headerNames.serviceRequest, "true");
    }

    _getBody() {
        var body = utils.serializeToJSON(this.request._getBody());
        return body;
    }

    _getMethod = function() {
        return this.request._getMethod();
    }

    _getHeaders = function () {
        return this.request._getHeaders();
    }

    _getQueryString = function (urlOptions: any) {
        return this.request._getQueryString(urlOptions);
    }

    _buildUrl = function () {
        return this.request._buildUrl();
    }
}
