import { utils } from '../utils';

var constants = require("../constants").default;
var headerNames = require("../Headers").headerNames;
var contentTypes = require("../ContentTypes").default;
var httpMethods = require("../HttpMethods").default;

export class RequestBase {
    public successCb: (data: any) => void;
    public failureCb: (data: any) => void;
    public progressCb: any;
    public key: string;
    private action: string;
    private _fallbackProperties: string[];
    public urlOptions: any;

    constructor (options: any) {
        this.successCb = options.successCb;
        this.failureCb = options.failureCb;
        this.urlOptions = options.urlOptions;
        this.progressCb = options.progressCb;
        this.key = options.key;
        this.action = options.action;
        this._fallbackProperties = options.fallbackProperties;
    }

    _getBody() {
        return undefined;
    }

    _getMethod() {
        return null;
    }

    _getHeaders(): any {
        var headers = {};
        headers[headerNames.contentType] = contentTypes.json;
        return headers;
    }

    _getQueryParameters(paramDictionary: any, urlOptions: any) {
        var clause = constants.SfParams;
        if (urlOptions.SFParams) {
            var sfParams = urlOptions.SFParams;
            if (sfParams.provider) {
                paramDictionary[clause.provider] = sfParams.provider;
            }

            if (sfParams.culture) {
                paramDictionary[clause.culture] = sfParams.culture;
            }

            if (sfParams.siteId) {
                paramDictionary[clause.siteId] = sfParams.siteId;
            }
        }

        if (this._fallbackProperties) {
            paramDictionary["sf_fallback_prop_names"] = this._fallbackProperties.join();
        }
    }

    _getQueryString(urlOptions: any) {
        var paramDictionary = {};

        this._getQueryParameters(paramDictionary, urlOptions);
        var keys = Object.keys(paramDictionary);
        if (keys.length == 0)
            return null;

        var queryString = "?";
        for (var prop in paramDictionary) {
            queryString += prop + "=" + paramDictionary[prop] + "&";
        }

        queryString = queryString.substring(0, queryString.length - 1);

        return queryString;
    }

    _buildUrl() {
        var url = this.urlOptions.baseUrl + (this.urlOptions.entitySet || "");
        url += this.key ? ("(" + this.key + ")") : "";
        if (this.action) {
            url += url.endsWith("/") ? "" : "/";
            url += this.action;
        }

        // including count here
        // not the best solution as build() is called once more in getQueryString
        // but not that big of an issue right now
        if (this.urlOptions.ODataParams) {
            var getCount = this.urlOptions.ODataParams.build().$count;

            if (utils.isBoolean(getCount) && !getCount) {
                url += "/$count";
            }
        }

        return this._addQueryParameters(url);
    }

    _parseResponse(http: any) {
        var data = utils.parseStringToJson(http.responseText);
        if (data) {
            if (http.status >= 400 && data.error) {
                return data.error;
            }

            return data;
        }

        return http.responseText;
    }

    _addQueryParameters (url: string) {
        var queryString = this._getQueryString(this.urlOptions);

        if (queryString) {
            if (url.indexOf("?") > -1 && queryString[0] == "?") {
                queryString = "&" + queryString.substring(1);
            }

            url += queryString;
        }

        return url;
    }
}

export class GetRequest extends RequestBase {
    constructor(options: any) {
        super(options);
    }

    _getMethod() {
        return httpMethods.Get;
    }

    _getQueryParameters(paramDictionary: any, urlOptions: any) {
        var clause = constants.ODataParams;

        if (urlOptions.ODataParams) {
            var query = urlOptions.ODataParams.build();
            if (utils.isString(query.$filter))
                paramDictionary[clause.$filter] = query.$filter;
            if (utils.isString(query.$select))
                paramDictionary[clause.$select] = query.$select;
            if (utils.isString(query.$expand))
                paramDictionary[clause.$expand] = query.$expand;
            if (utils.isString(query.$orderby))
                paramDictionary[clause.$orderby] = query.$orderby;
            if (utils.isNumber(query.$skip))
                paramDictionary[clause.$skip] = query.$skip;
            if (utils.isNumber(query.$top))
                paramDictionary[clause.$top] = query.$top;
            if (utils.isString(query.$search))
                paramDictionary[clause.$search] = query.$search;

            // inline count
            if (utils.isBoolean(query.$count) && query.$count)
                paramDictionary[clause.$count] = query.$count;
        }

        super._getQueryParameters(paramDictionary, urlOptions);
    }
}

export class GetByIdRequest extends RequestBase {
    constructor(options: any) {
        super(options);
    }

    _getMethod() {
        return httpMethods.Get;
    }

    _getQueryParameters(paramDictionary, urlOptions) {
        var clause = constants.ODataParams;

        if (urlOptions.ODataParams) {
            var query = urlOptions.ODataParams.build();
            if (utils.isString(query.$select))
                paramDictionary[clause.$select] = query.$select;
            if (utils.isString(query.$expand))
                paramDictionary[clause.$expand] = query.$expand;
        }

        super._getQueryParameters(paramDictionary, urlOptions);
    }
}

export class DeleteRequest extends RequestBase {
    constructor(options: any) {
        super(options);
    }

    _getMethod() {
        return httpMethods.Delete;
    }
}

export class UpdateRequest extends RequestBase {
    private _data: any;
    private _saveTemp: any;
    constructor(options: any) {
        super(options);
        this._data = options.data;
        this._saveTemp = options.saveTemp;
    }

    _getMethod() {
        return httpMethods.Patch;
    }

    _getBody() {
        var body = utils.convertDateFieldToISOString(this._data);
        return body;
    }

    _getHeaders() {
        var headers = RequestBase.prototype._getHeaders.call(this);
        if (this._saveTemp) {
            headers[headerNames.operation] = "SaveTemp";
        }

        return headers;
    }
}

export class CreateRequest extends RequestBase {
    public _data: any;
    constructor(options: any) {
        super(options);
        this._data = options.data;
    }

    _getMethod() {
        return httpMethods.Post;
    }

    _getBody() {
        var body = utils.convertDateFieldToISOString(this._data);
        return body;
    }
}

export class GetRelatedRequest extends GetByIdRequest {
    private navigationProperty: string;
    constructor(options: any) {
        super(options);
        this.navigationProperty = options.navigationProperty;
    }

    _buildUrl() {
        var url = this.urlOptions.baseUrl + this.urlOptions.entitySet + "(" + this.key + ")/" + this.navigationProperty;
        return this._addQueryParameters(url);
    }
}

export class GetRelatedByIdRequest extends GetByIdRequest {
    private navigationProperty: string;
    private relatedKey: string;
    constructor(options: any) {
        super(options);
        this.navigationProperty = options.navigationProperty;
        this.relatedKey = options.relatedKey;
    }

    _buildUrl() {
        var url = this.urlOptions.baseUrl + this.urlOptions.entitySet + "(" + this.key + ")/" + this.navigationProperty + "(" + this.relatedKey + ")";
        return this._addQueryParameters(url);
    }
}

export class DeleteRelatedRequest extends DeleteRequest {
    private navigationProperty: string;
    constructor(options: any) {
        super(options);
        this.navigationProperty = options.navigationProperty;
    }


    _buildUrl() {
        var url = this.urlOptions.baseUrl + this.urlOptions.entitySet + "(" + this.key + ")/" + this.navigationProperty + "/$ref"
        return this._addQueryParameters(url);
    }
}

export class DeleteRelatedByIdRequest extends DeleteRequest {
    private navigationProperty: string;
    private relatedKey: string;
    constructor(options: any) {
        super(options);
        this.navigationProperty = options.navigationProperty;
        this.relatedKey = options.relatedKey
    }

    _buildUrl() {
        var url = this.urlOptions.baseUrl + this.urlOptions.entitySet + "(" + this.key + ")/" + this.navigationProperty + "(" + this.relatedKey + ")/$ref";
        return this._addQueryParameters(url);
    }
}

export class CreateRelatedRequest extends CreateRequest {
    private navigationProperty: string;
    constructor(options: any) {
        super(options);
        this.navigationProperty = options.navigationProperty;
        this.key = options.key;
    }

    _buildUrl() {
        var url = this.urlOptions.baseUrl + this.urlOptions.entitySet + "(" + this.key + ")/" + this.navigationProperty + "/$ref";
        return this._addQueryParameters(url);
    }
}


export class UploadRequest extends CreateRequest {
    private fileName: any;
    private uploadProperties: any;
    private contentType: any;

    constructor(options: any) {
        super(options);
        this.fileName = options.fileName;
        this.uploadProperties = options.uploadProperties;
        this.contentType = options.contentType;
    }

    _getHeaders() {
        var headers = super._getHeaders();
        headers[headerNames.contentType] = this.contentType || "application/octet-stream";
        headers[headerNames.fileName] = this.fileName;
        headers[headerNames.properties] = this.uploadProperties;
        headers[headerNames.contentEncoding] = "identity";
        return headers;
    }

    _getBody() {
        return this._data;
    }

    _getMethod() {
        if (this.key) {
            return httpMethods.Patch;
        }

        return httpMethods.Post;
    }
}
