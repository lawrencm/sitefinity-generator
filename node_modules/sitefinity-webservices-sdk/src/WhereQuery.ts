import { ComplexExpression, BinaryExpression } from './Expression';
const OperatorType = require('./constants').default.ExpressionType;

/**
 * @classdesc A fluent API operation for creating a filter for a query by chaining different rules.
 * @class WhereQuery
 * @protected
 */
export class WhereQuery {

    private expression: ComplexExpression;
    constructor(private parent: any, type: string = OperatorType.and) {
        this.expression = new ComplexExpression(type, []);
    }

     /**
     * Adds an `and` clause to the current condition and returns it for further chaining.
     * @method and
     * @memberOf WhereQuery.prototype
     * @returns {WhereQuery}
     */
    and(): WhereQuery {
        return new WhereQuery(this, OperatorType.and);
    }
    /**
     * Adds an `or` clause to the current condition and returns it for further chaining.
     * @method or
     * @memberOf WhereQuery.prototype
     * @returns {WhereQuery}
     */
    or(): WhereQuery {
        return new WhereQuery(this, OperatorType.or);
    }

    /**
     * Adds an `any` clause to the current condition and returns it for further chaining.
     * @method any
     * @memberOf WhereQuery.prototype
     * @returns {WhereQuery}
     */
    any(): WhereQuery {
        return new WhereQuery(this, OperatorType.any);
    }
    /**
     * Adds a `not` clause to the current condition and returns it for further chaining.
     * @method not
     * @memberOf WhereQuery.prototype
     * @returns {WhereQuery}
     */
    not(): WhereQuery {
        return new WhereQuery(this, OperatorType.not);
    }

    private _simple (type: string, parameter: string, constant: any): WhereQuery {
        var currentExpr = new BinaryExpression(type, parameter, constant);
        var subExpressions = this.expression.getExpressions();
        subExpressions.push(currentExpr);

        if (this.expression.getType() === OperatorType.not && subExpressions.length > 1)
            throw new Error("Invalid operators count!");

        return this;
    }

    /**
     * Adds a condition that a field must be equal to a specific value.
     * @method eq
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {*} value Comparison value (to which the fields must be equal).
     * @returns {WhereQuery}
     */
    eq(parameter: string, constant: any): WhereQuery {
        return this._simple(OperatorType.eq, parameter, constant);
    }
    /**
     * Adds a condition that a field must *not* be equal to a specific value.
     * @method ne
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {*} value Comparison value (to which the field must not be equal).
     * @returns {WhereQuery}
     */
    ne(parameter: string, constant: any): WhereQuery {
        return this._simple(OperatorType.ne, parameter, constant);
    }
    /**
     * Adds a condition that a field must be `greater than` a certain value. Applicable to Number, String, and Date fields.
     * @method gt
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {*} value Comparison value (that the field should be greater than).
     * @returns {WhereQuery}
     */
    gt(parameter: string, constant: any) {
        return this._simple(OperatorType.gt, parameter, constant);
    }
    /**
     * Adds a condition that a field must be `greater than or equal` to a certain value. Applicable to Number, String, and Date fields.
     * @method gte
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {*} value Comparison value (that the field should be greater than or equal to).
     * @returns {WhereQuery}
     */
    gte(parameter: string, constant: any) {
        return this._simple(OperatorType.ge, parameter, constant);
    }
    /**
     * Adds a condition that a field must be `less than` a certain value. Applicable to Number, String, and Date fields.
     * @method lt
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {*} value Comparison value (that the field should be less than).
     * @returns {WhereQuery}
     */
    lt(parameter: string, constant: any) {
        return this._simple(OperatorType.lt, parameter, constant);
    }
    /**
     * Adds a condition that a field must be `less than or equal` to a certain value. Applicable to Number, String, and Date fields.
     * @method lte
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {*} value Comparison value (that the field should be less than or equal to).
     * @returns {WhereQuery}
     */
    lte(parameter: string, constant: any) {
        return this._simple(OperatorType.le, parameter, constant);
    }
    /**
     * Adds a condition that a field value must *start* with a specified string.
     * @method startsWith
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {string} value The string that the field should start with.
     * @param {string} [options] A string of regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
     * @returns {WhereQuery}
     */
    startsWith(parameter: string, constant: any): WhereQuery {
        return this._simple(OperatorType.startsWith, parameter, constant);
    }

    /**
     * Adds a condition that a field value must *contain* a specified string.
     * @method startsWith
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {string} value The string that the field should start with.
     * @param {string} [options] A string of regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
     * @returns {WhereQuery}
     */
    contains(parameter: string, constant: any) {
        return this._simple(OperatorType.contains, parameter, constant);
    }

    /**
     * Adds a condition that a field value must *end* with a specified string.
     * @method endsWith
     * @memberOf WhereQuery.prototype
     * @param {string} field Field name.
     * @param {string} value The string that the field should end with.
     * @param {string} [options] A string of  regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
     * @returns {WhereQuery}
     */
    endsWith(parameter: string, constant: any) {
        return this._simple(OperatorType.endsWith, parameter, constant);
    }

    /**
     * Ends the definition of the current WhereQuery. You need to call this method in order to continue with the definition of the parent {@link QueryBase}. All other `WhereQuery` methods return the current instance of `WhereQuery` to allow chaining.
     * @method done
     * @memberOf WhereQuery.prototype
     * @returns {Query}
     */
    done() {
        if (this.parent instanceof WhereQuery) {
            this.parent._addComplexExpression(this);
            // TODO: If has and() || or() must call done() twice
            if (this.expression.getType() === OperatorType.not)
                return this.parent;
        }

        return this.parent;
    }

    _getExpression () {
        return this.expression;
    }

    private _addComplexExpression(subQuery): void {
        var subExpression = subQuery._getExpression();
        this.expression.getExpressions().push(subExpression);
    }
}
