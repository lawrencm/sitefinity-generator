import { WhereQuery } from './WhereQuery';
import { ComplexExpression, BinaryExpression } from './Expression';
import { OrderProperty } from './OrderProperty';
import { utils } from './utils';

var constants = require('./constants').default;

export class QueryBuilder {
    constructor(private query: any) {

    }

    build(): any {
        var queryParameters = {};
        this._buildODataQueryParams(this.query, queryParameters);
        return queryParameters;
    }

    private _buildODataQueryParams(query, queryParameters) {
        var queryParams = constants.ODataParams;

        var whereClause = query._getFilter();
        if (whereClause instanceof WhereQuery) {
            var expression = whereClause._getExpression();
            if (expression instanceof ComplexExpression) {
                var result = this._buildComplexExpression(expression, null);
                if (result) {
                    queryParameters[queryParams.$filter] = result;
                }
            }
        }

        var selectClause = query._getSelect();
        if (selectClause instanceof Array) {
            queryParameters[queryParams.$select] = selectClause.join(', ');
        }

        var expandClause = query._getExpand();
        if (expandClause instanceof Array)
            queryParameters[queryParams.$expand] = expandClause.join(', ');

        var orderByClause = query._order;
        if (orderByClause instanceof Array) {
            var order = [];
            for (var i in orderByClause) {
                if (orderByClause[i] instanceof OrderProperty)
                    order.push(orderByClause[i].getValue());
            }
            queryParameters[queryParams.$orderby] = order.join(', ');
        }

        var take = query._take;
        if (utils.isNumber(take))
            queryParameters[queryParams.$top] = take;

        var skip = query._skip;
        if (utils.isNumber(skip))
            queryParameters[queryParams.$skip] = skip;

        var search = query._search;
        if (search)
            queryParameters[queryParams.$search] = search;

        var count = query._count;

        // means that the count is required inline
        if (count !== null) {
            queryParameters[queryParams.$count] = count;
        }

        return queryParameters;
    }

    private _buildComplexExpression(expression, parent) {
        if (!(expression instanceof ComplexExpression))
            throw new Error('Invalid complex expression');

        var OperatorType = constants.ExpressionType;
        var counter = 0;
        var result = '';
        var subExpressions = expression.getExpressions();
        if (!subExpressions.length) {
            return result;
        }

        while (true) {
            var currentExp = subExpressions[counter];
            if (currentExp instanceof BinaryExpression) {
                result += this._buildBinaryExpression(currentExp);
            }
            else if (currentExp instanceof ComplexExpression) {
                var complexResult = this._buildComplexExpression(currentExp, expression.type);
                if (complexResult) {
                    result += '(' + complexResult + ')';
                }
            }

            if (expression.getType() === OperatorType.not)
                result = expression.getType() + ' ' + result;
            // TODOSDK: Rethink this!
            if (expression.getType() === OperatorType.any) {
                var exprVal = [];
                for (var index = 0; index < subExpressions.length; index++) {
                    if (subExpressions[index].type == OperatorType.contains || subExpressions[index].type == OperatorType.startsWith || subExpressions[index].type == OperatorType.endsWith)
                        exprVal.push(subExpressions[index].type.toLowerCase() + "(x, '" + (subExpressions[index] as BinaryExpression).constant + "')");
                    else
                        exprVal.push('x ' + subExpressions[index].type.toLowerCase() + ' ' + this._checkType((subExpressions[index] as BinaryExpression).constant));
                }
                result = (currentExp as BinaryExpression).parameter + '/' + expression.getType() + '(x:' + exprVal.join(' ' + parent + ' ') + ')';
            }

            counter++;
            if (counter == subExpressions.length)
                break;

            result += ' ' + expression.getType() + ' ';
        }

        return result;
    }

    private _buildBinaryExpression(expression) {
        if (!(expression instanceof BinaryExpression))
            throw new Error('Invalid binary expression');

        var ExpressionType = constants.ExpressionType;
        var result = null;
        var type = expression.getType();
        switch (type) {
            case ExpressionType.eq:
            case ExpressionType.ne:
            case ExpressionType.lt:
            case ExpressionType.le:
            case ExpressionType.gt:
            case ExpressionType.ge:
                var constant = expression.getConstant();
                /*var template = '({0} {1} \'{2}\')';
                if (/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(constant))
                    template = '({0} {1} {2})';*/

                result = `(${expression.getParameter()} ${type} ${this._checkType(constant)})`;
                break;
                // TODO contains is substringOf in Odata ?
            case ExpressionType.contains:
            case ExpressionType.startsWith:
            case ExpressionType.endsWith:
                result = `${type.toLowerCase()}(${expression.getParameter()}, ${this._checkType(expression.getConstant())})`;
                break;
            default:
                var msg = `Unsupported operator ${type}`;
                throw new Error(msg);
        }

        return result;
    }

    private _checkType(constant: any) {
        if (this._isGuid(constant))
            return constant;

        if (constant == null)
            return null;

        constant = constant.replace(/[+/?%#&]/g, function($0) {
            return encodeURIComponent($0);
        });

         // escapes the apostrophes
        constant = constant.replace(/'/g,"''");

        return "'" + constant + "'";
    }

    private _isGuid(constant: string) {
        return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(constant);
    }
}
